"""
NWB Inspector integration wrapper for the agentic neurodata conversion system.

This module provides a standardized interface to NWB Inspector functionality
for validating and inspecting NWB files generated by the conversion pipeline.
"""

import logging
from pathlib import Path
from typing import Any, Optional, Union

logger = logging.getLogger(__name__)


class NWBInspectorInterface:
    """
    Wrapper interface for NWB Inspector functionality.

    Provides standardized methods for validating NWB files, generating
    inspection reports, and checking compliance with NWB standards.
    """

    def __init__(self):
        """Initialize NWB Inspector interface."""
        self._initialized = False

    def initialize(self) -> bool:
        """
        Initialize NWB Inspector dependencies.

        Returns:
            bool: True if initialization successful, False otherwise
        """
        try:
            # Import NWB Inspector when needed to avoid hard dependency
            import nwbinspector  # noqa: F401

            self._initialized = True
            logger.info("NWB Inspector interface initialized successfully")
            return True
        except ImportError as e:
            logger.warning(f"NWB Inspector not available: {e}")
            self._initialized = False
            return False

    def inspect_nwb_file(
        self, nwb_file_path: Union[str, Path], config: Optional[dict[str, Any]] = None
    ) -> dict[str, Any]:
        """
        Inspect NWB file for compliance and best practices.

        Args:
            nwb_file_path: Path to NWB file to inspect
            config: Optional configuration for inspection

        Returns:
            Inspection results with messages and severity levels
        """
        if not self._initialized and not self.initialize():
            return {"status": "error", "message": "NWB Inspector not available"}

        nwb_file_path = Path(nwb_file_path)

        if not nwb_file_path.exists():
            return {
                "status": "error",
                "message": f"NWB file not found: {nwb_file_path}",
            }

        try:
            logger.info(f"Inspecting NWB file: {nwb_file_path}")

            # Placeholder for actual NWB Inspector calls
            # This would use nwbinspector.inspect_nwbfile()

            # Example inspection results structure
            inspection_results = {
                "status": "success",
                "file_path": str(nwb_file_path),
                "messages": [
                    {
                        "message": "File structure is valid",
                        "severity": "info",
                        "check_function_name": "check_file_structure",
                    }
                ],
                "summary": {
                    "total_messages": 1,
                    "critical": 0,
                    "error": 0,
                    "warning": 0,
                    "info": 1,
                },
            }

            logger.info(
                f"Inspection completed with {inspection_results['summary']['total_messages']} messages"
            )
            return inspection_results

        except Exception as e:
            logger.error(f"NWB inspection failed: {e}")
            return {"status": "error", "message": str(e)}

    def validate_nwb_compliance(
        self, nwb_file_path: Union[str, Path], strict: bool = False
    ) -> dict[str, Any]:
        """
        Validate NWB file compliance with standards.

        Args:
            nwb_file_path: Path to NWB file to validate
            strict: Whether to use strict validation rules

        Returns:
            Validation results with compliance status
        """
        if not self._initialized and not self.initialize():
            return {"status": "error", "message": "NWB Inspector not available"}

        try:
            inspection_results = self.inspect_nwb_file(nwb_file_path)

            if inspection_results.get("status") != "success":
                return inspection_results

            # Analyze inspection results for compliance
            summary = inspection_results.get("summary", {})
            critical_count = summary.get("critical", 0)
            error_count = summary.get("error", 0)
            warning_count = summary.get("warning", 0)

            # Determine compliance based on message severity
            if critical_count > 0 or error_count > 0:
                compliance_status = "non_compliant"
            elif strict and warning_count > 0:
                compliance_status = "non_compliant_strict"
            else:
                compliance_status = "compliant"

            return {
                "status": "success",
                "compliance_status": compliance_status,
                "file_path": str(nwb_file_path),
                "issues": {
                    "critical": critical_count,
                    "error": error_count,
                    "warning": warning_count,
                },
                "messages": inspection_results.get("messages", []),
            }

        except Exception as e:
            logger.error(f"Compliance validation failed: {e}")
            return {"status": "error", "message": str(e)}

    def generate_inspection_report(
        self,
        nwb_file_path: Union[str, Path],
        output_path: Optional[Union[str, Path]] = None,
        format: str = "txt",
    ) -> dict[str, Any]:
        """
        Generate detailed inspection report for NWB file.

        Args:
            nwb_file_path: Path to NWB file to inspect
            output_path: Optional path for report output
            format: Report format ('txt', 'json', 'html')

        Returns:
            Report generation results
        """
        if not self._initialized and not self.initialize():
            return {"status": "error", "message": "NWB Inspector not available"}

        try:
            inspection_results = self.inspect_nwb_file(nwb_file_path)

            if inspection_results.get("status") != "success":
                return inspection_results

            # Generate report in requested format
            if output_path is None:
                nwb_path = Path(nwb_file_path)
                output_path = (
                    nwb_path.parent / f"{nwb_path.stem}_inspection_report.{format}"
                )
            else:
                output_path = Path(output_path)

            report_content = self._format_inspection_report(inspection_results, format)

            # Write report to file
            output_path.parent.mkdir(parents=True, exist_ok=True)

            if format == "json":
                import json

                with open(output_path, "w") as f:
                    json.dump(inspection_results, f, indent=2)
            else:
                with open(output_path, "w") as f:
                    f.write(report_content)

            logger.info(f"Inspection report generated: {output_path}")

            return {
                "status": "success",
                "report_path": str(output_path),
                "format": format,
                "summary": inspection_results.get("summary", {}),
            }

        except Exception as e:
            logger.error(f"Report generation failed: {e}")
            return {"status": "error", "message": str(e)}

    def _format_inspection_report(
        self, inspection_results: dict[str, Any], format: str
    ) -> str:
        """
        Format inspection results into readable report.

        Args:
            inspection_results: Results from NWB inspection
            format: Output format ('txt', 'html')

        Returns:
            Formatted report content
        """
        if format == "html":
            return self._format_html_report(inspection_results)
        else:
            return self._format_text_report(inspection_results)

    def _format_text_report(self, inspection_results: dict[str, Any]) -> str:
        """Format inspection results as plain text report."""
        lines = [
            "NWB Inspector Report",
            "=" * 50,
            f"File: {inspection_results.get('file_path', 'Unknown')}",
            f"Inspection Date: {inspection_results.get('timestamp', 'Unknown')}",
            "",
            "Summary:",
            f"  Total Messages: {inspection_results.get('summary', {}).get('total_messages', 0)}",
            f"  Critical: {inspection_results.get('summary', {}).get('critical', 0)}",
            f"  Errors: {inspection_results.get('summary', {}).get('error', 0)}",
            f"  Warnings: {inspection_results.get('summary', {}).get('warning', 0)}",
            f"  Info: {inspection_results.get('summary', {}).get('info', 0)}",
            "",
            "Messages:",
            "-" * 30,
        ]

        for msg in inspection_results.get("messages", []):
            lines.extend(
                [
                    f"[{msg.get('severity', 'unknown').upper()}] {msg.get('message', '')}",
                    f"  Check: {msg.get('check_function_name', 'unknown')}",
                    "",
                ]
            )

        return "\n".join(lines)

    def _format_html_report(self, inspection_results: dict[str, Any]) -> str:
        """Format inspection results as HTML report."""
        html_template = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>NWB Inspector Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .header { background-color: #f0f0f0; padding: 10px; }
                .summary { margin: 20px 0; }
                .message { margin: 10px 0; padding: 10px; border-left: 4px solid #ccc; }
                .critical { border-left-color: #d32f2f; }
                .error { border-left-color: #f57c00; }
                .warning { border-left-color: #fbc02d; }
                .info { border-left-color: #1976d2; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>NWB Inspector Report</h1>
                <p>File: {file_path}</p>
            </div>

            <div class="summary">
                <h2>Summary</h2>
                <ul>
                    <li>Total Messages: {total_messages}</li>
                    <li>Critical: {critical}</li>
                    <li>Errors: {errors}</li>
                    <li>Warnings: {warnings}</li>
                    <li>Info: {info}</li>
                </ul>
            </div>

            <div class="messages">
                <h2>Messages</h2>
                {message_list}
            </div>
        </body>
        </html>
        """

        # Format messages
        message_html = []
        for msg in inspection_results.get("messages", []):
            severity = msg.get("severity", "info")
            message_html.append(f"""
                <div class="message {severity}">
                    <strong>[{severity.upper()}]</strong> {msg.get("message", "")}
                    <br><small>Check: {msg.get("check_function_name", "unknown")}</small>
                </div>
            """)

        summary = inspection_results.get("summary", {})

        return html_template.format(
            file_path=inspection_results.get("file_path", "Unknown"),
            total_messages=summary.get("total_messages", 0),
            critical=summary.get("critical", 0),
            errors=summary.get("error", 0),
            warnings=summary.get("warning", 0),
            info=summary.get("info", 0),
            message_list="".join(message_html),
        )

    def get_available_checks(self) -> list[dict[str, Any]]:
        """
        Get list of available NWB Inspector checks.

        Returns:
            List of available inspection checks with descriptions
        """
        if not self._initialized and not self.initialize():
            return []

        try:
            # Placeholder for getting available checks from NWB Inspector
            # This would query nwbinspector for available check functions
            available_checks = [
                {
                    "name": "check_file_structure",
                    "description": "Validate basic NWB file structure",
                    "severity": "error",
                },
                {
                    "name": "check_timestamps",
                    "description": "Validate timestamp consistency",
                    "severity": "warning",
                },
                {
                    "name": "check_data_orientation",
                    "description": "Check data array orientations",
                    "severity": "warning",
                },
            ]

            logger.info(f"Found {len(available_checks)} available checks")
            return available_checks

        except Exception as e:
            logger.error(f"Failed to get available checks: {e}")
            return []
